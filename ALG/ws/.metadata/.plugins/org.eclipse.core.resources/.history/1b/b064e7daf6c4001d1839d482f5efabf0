package algestudiante.p4;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Defensa 
{
	public static final String PATH = System.getProperty("user.dir") + 
			"\\src\\main\\java\\algestudiante\\p4\\";
	
	// Datos de entrada
	private int n;						// Nï¿½mero de ciudades invadidas (coincide con el nï¿½mero de equipos)
	private int[] enemigos;				// Nï¿½mero de efectivos enemigos en cada ciudad (ei)
	private int[] grupoDefensaRapida;	// Efectivos de defensa en cada equipo (di)
	
	// trabajo
	private boolean[] asignados;		// Equipos de defensa ya asignados
	
	// soluciï¿½n
	private int[] asignacion;			// Asignaciï¿½n de defensa a ciudades (ï¿½ndice del equipo de defensa rï¿½pida)
	private int numVictorias;			// Nï¿½mero de victorias conseguidas con la asignaciï¿½n
	
	/**
	 * Constructor que recibe los arrays para empezar a trabajar
	 * @param n	nï¿½mero de ciudades invadidas
	 * @param enemigos	efectivos enemigos en cada ciudad 
	 * @param grupoDefensaRapida	efectivos en cada grupo de defensa rï¿½pida
	 */
	public Defensa(int n, int[] enemigos, int[] grupoDefensaRapida)
	{
		this.n= n;	// Ciudades invadidas
		
		this.enemigos= new int[n];
		this.grupoDefensaRapida= new int[n];
		asignados= new boolean[n];
		asignacion = new int[n];
		
		for (int i= 0; i<n; i++)
		{
			this.enemigos[i]= enemigos[i]; 
			this.grupoDefensaRapida[i]= grupoDefensaRapida[i]; 
			this.asignados[i]= false;
		}
		numVictorias= 0;
		
	}
	
	/**
	 * Recibe los nombres de los ficheros para cargarlos y trabajar con ellos
	 * @param nomFichEnemigos	efectivos enemigos en cada ciudad
	 * @param nomFichDefensa	efectivos en cada grupo de defensa rï¿½pida
	 */
	public Defensa(String nomFichEnemigos, String nomFichDefensa) {
		enemigos= cargarArrayEnteros(PATH + nomFichEnemigos);
		grupoDefensaRapida= cargarArrayEnteros(PATH + nomFichDefensa);
		n= enemigos.length;
		asignados= new boolean[n];
		asignacion = new int[n];
		
		for (int i= 0; i<n; i++)
		{
			this.asignados[i]= false;
		}
		numVictorias= 0;
	}
	
	/**
	 * Carga desde fichero un array de enteros
	 * @param file nombre del fichero
	 * @return array de enteros cargado
	 */
	public static int[] cargarArrayEnteros(String file) {
		List<Integer> input = new ArrayList<Integer>();
		
		try (Stream<String> lines = Files.lines(Paths.get(file))) {
			for (String line : lines.collect(Collectors.toList())) {    //lines.toList()) {
				String[] info = line.split("\t");
				input.add(Integer.parseInt(info[1]));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return input.stream()
                .mapToInt(Integer::intValue)
                .toArray();
	}
	
	/**
	 * Soluciï¿½n:
	 * Asigna cada equipo de defensa a una ciudad
	 * De tal forma que optimicemos las victorias
	 * @return 	array con los equipos de defensa asignados a cada ciudad
	 */
	public int[] asignar()
	{
		// Solución voraz para este problema partiendo de los datos que ya tenemos
		// se pueden crear los mï¿½todos privados que se consideren necesarios
		// El heurÃ­stico que se busca es el mayor de mayorDef/mayorEne
		//Probar con si coef >= 1.0 tiene que estar entre 1.0 y coef
		for (int i= 0; i < enemigos.length; i++) {
			double coef = 0.0;
			int pos = -1;
			for (int j = 0; j < grupoDefensaRapida.length;j++) {
				if(asignados[j] == false) {
					double auxCoef = (grupoDefensaRapida[j]*1.0) / (enemigos[i]*1.0);
					if(coef >= 1.0) {
						if (auxCoef > 1.0 && auxCoef < coef) {
							coef = auxCoef;
							pos = j;
						}
					} else {
						coef = auxCoef;
						pos = j;
					}
				}
			}
			if(coef >= 1.0) {
				asignacion[i] = pos;
				asignados[pos] = true;
				numVictorias++;
			} else {
				pos = calculaMinimo(this.grupoDefensaRapida);
				asignacion[i] = pos;
				asignados[pos] = true;
			}
		}
		return asignacion;
	}
	
	public int[] asignar2() {
		List defensas = Arrays.asList(this.grupoDefensaRapida);
		List enemigos = Arrays.asList(this.enemigos);;
//		defensas = Arrays.asList(this.grupoDefensaRapida);
//		enemigos = Arrays.asList(this.enemigos);
		int count = 0;
		for (int i = 0; i < defensas.size(); i++) {
			System.out.println("The list is: " + defensas);
		}
		
		return new int[0];
	}

	private int calculaMinimo(int[] array) {
		int min = Integer.MAX_VALUE;
		int pos = -1;
		for(int i = 0; i < array.length; i++) {
			if (asignados[i] == false && array[i] < min) {
				min = array[i];
				pos = i;
			}
		}
		return pos;
	}

	/**
	 * Muestra en consola, los ï¿½ndices de las ciudades invadidas, los efectivos enemigos y 
	 * los efectivos de defensa asignados y 
	 * el resultado final en funciï¿½n de esta asignaciï¿½n: Victoria / Derrota
	 */
	public void mostrarPlanDefensaVertical()
	{
		System.out.println("Nï¿½ ciudad invadida");
		System.out.println("\tEfectivos enemigos:");
		System.out.println("\t\tEfectivos de defensa");
		System.out.println("\t\t\tIndice equipo defensa");
		System.out.println("\t\t\t\tResultado batalla:");
		for (int i= 0; i<n; i++)
		{
			System.out.print(i+"\t");
			System.out.print(enemigos[i]+"\t");
			System.out.print(grupoDefensaRapida[asignacion[i]]+"\t");
			System.out.print(asignacion[i]+"\t");
			System.out.print((grupoDefensaRapida[asignacion[i]]>=enemigos[i]?"Vict. +":"Derr. ï¿½")+"\t");
			System.out.println();
		}
		System.out.println("Total victorias: "+ numVictorias+ " / "+n);
		
	}

	/**
	 * Genera array aleatorio con los enemigos
	 * @param n nï¿½mero de ciudades que se quieren representar
	 * @return array con los efectivos enemigos por ciudad
	 */
	public static int[] generarEnemigos(int n)
	{
		Random r= new Random ();
		int[] enemigos= new int[n];
		
		for (int i= 0; i<n; i++)
		{
			enemigos[i]= r.nextInt(1000);
		}
		
		return enemigos;
	}
	
	/**
	 * Genera array aleatorio con los equipos de defensa
	 * @param n Nï¿½mero de equipos de defensa
	 * @return array con los efectivos de defensa por cada equipo
	 */
	public static int[] generarGrupoDefensa(int n)
	{
		Random r= new Random ();
		int[] grupoDefensaRapida= new int[n];
		
		for (int i= 0; i<n; i++)
		{
			grupoDefensaRapida[i]= r.nextInt(1000);
		}
		
		return grupoDefensaRapida;		
	}
	
	/**
	 *  Devuelve asignaciï¿½n grupos de defensa (soluciï¿½n)
	 * @return
	 */
	public int[] getAsignacion() {
		return asignacion;
	}
	
	/**
	 * Devuelve el nï¿½mero de victorias conseguidas
	 * @return Asignaciï¿½n de defensa a ciudades (ï¿½ndice del equipo de defensa rï¿½pida)
	 */
	public int getNumVictorias() {
		return numVictorias;
	}
	
	/* Prueba el algoritmo de asignaciï¿½n */
	public static void main(String[] args)
	{
		int n= 10;
		int[] enemigos= generarEnemigos(n);	
//		int[] enemigos= {8,3,6};
		int[] grupoDefensaRapida= generarGrupoDefensa(n);	
//		int[] grupoDefensaRapida= {2, 10, 3};
		
//		Defensa pais= new Defensa(enemigos.length, enemigos, grupoDefensaRapida);
		Defensa pais= new Defensa("enemigos10.txt","defensa10.txt");
		pais.asignar();
		pais.mostrarPlanDefensaVertical();
	}

}
